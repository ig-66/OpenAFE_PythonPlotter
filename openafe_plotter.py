# Adjust the parameters below according to your needs:
# 
# NOTE: Keep in mind that some voltammetry waves may not be 
# generated by the AFE, those will return an error.
# 
# Comment or de-comment the voltammetry type as needed.
# 
# Parameters:
voltammetryType = "CV" # Cyclic Voltammetry
# voltammetryType = "DPV" # Differential Pulse Voltammetry (NOT YET IMPLEMENTED)
# voltammetryType = "SW" # Square Wave (NOT YET IMPLEMENTED)
startingPotential_millivolts = -500
endingPotential_millivolts = 500
scanRate_millivoltsPerSecond = 250
stepSize_millivolts = 2
numberOfCycles = 1
settlingTime_milliseconds = 0 # (NOT YET IMPLETMENTED)

# Graph Options:
graphTitle = "H2O + NaCl Cyclic Voltammetry" # the graph title to be displayed, can be left in blank
graphSubTitle = "" # the graph sub title, can be left blank
gridVisible = True # Change to True or False, to make the grid visible or hidden, respectively


import matplotlib.pyplot as plt
from collections import deque
import serial


def getMessageFromOpenAFE():
	"""
	The function `getMessageFromOpenAFE` reads a message from a serial port, checks its checksum, and
	returns the message if the checksum is valid, otherwise it returns -1.
	:return: either the message received from OpenAFE if the checksum is valid, or -1 if the checksum is
	not valid.
	"""
	messageReceived=str(ser.readline())
	rawMessage = messageReceived[2:][:-5]
	
	# check the message's checksum ...
	calculatedChecksum = calculateChecksumOfString(messageReceived[3:][:-8])
	checksumInMessage = getChecksumIntegerFromString(rawMessage[-2:])

	if (calculatedChecksum - checksumInMessage) == 0:
		# checksum is valid
		message = messageReceived[3:][:-8] 
		return message
	else :
		# checksum is not valid
		return -1


def calculateChecksumOfString(string):
	"""
	The function `calculateChecksumOfString` calculates the checksum of a given string by performing a
	bitwise XOR operation on the ASCII values of its characters.
	
	:param string: The parameter "string" is a string of characters for which we want to calculate the
	checksum, e.g.: "CVW,500,-500,250,2,1".
	:return: the checksum of the given string, e.g.: 119 (0x77).
	"""
	checksum = 0
	for char in string:
		checksum = (checksum ^ ord(char))
	return checksum


def getChecksumIntegerFromString(checksumString):
	"""
	The function `getChecksumIntegerFromString` converts a string representation of a checksum into an
	integer value.
	
	:param checksumString: The `checksumString` parameter is a string that represents a checksum, e.g.: "32".
	:return: an integer checksum value e.g.: 50 (0x32).
	"""
	integerChecksum = 0
	index = 1

	for char in checksumString:
		if ord(char) < 0x41:
			integerChecksum |= (ord(char) - 0x30) << (index * 4)
		else:
			integerChecksum |= (ord(char) - 0x37) << (index * 4)
		index -= 1

	return integerChecksum


def sendCommandToMCU(command):
	"""
	The function `sendCommandToMCU` sends a command to a microcontroller unit (MCU) by calculating a
	checksum, constructing a full command string, and writing it to a serial port.
	
	:param command: The `command` parameter is a string that represents the command to be sent to the
	MCU (Microcontroller Unit), e.g.: "CVW,500,-500,250,2,1".
	"""
	checksumString = hex(calculateChecksumOfString(command))
	checksumString = checksumString[2:] # removes the "0x"
	fullCommand = "$" + command + "*" + checksumString
	ser.write(fullCommand.encode("utf-8"))


def plotPoints(queVoltage, queCurrent):
	"""
	The function "plotPoints" plots points on a graph and sets the y-axis range.
	
	:param queVoltage: The queVoltage parameter represents the list of voltage values that you want to
	plot on the x-axis. Each value in the list corresponds to a point on the plot
	:param queCurrent: The queCurrent parameter represents the list of current values that you want to
	plot on the y-axis. Each value in the list corresponds to a specific point on the plot
	"""
	plt.clf()
	plt.suptitle(graphTitle)
	plt.title(graphSubTitle)
	plt.xlabel('Voltage (mV)')
	plt.ylabel('Current (uA)')
	plt.grid(visible=gridVisible)

	# PLOTTING THE POINTS
	plt.plot(queVoltage, queCurrent)

	# SET Y AXIS RANGE
	plt.xlim(-600,600)

	# DRAW, PAUSE AND CLEAR
	plt.draw()
	plt.pause(0.05)


def makeCyclicVoltammetry(endingPotential, startingPotential, scanRate, stepSize, numberOfCycles, settlingTime):
	"""
	The function "makeCyclicVoltammetry" sends a command string to a microcontroller unit (MCU) to
	perform cyclic voltammetry with specified parameters.
	
	:param endingPotential: The ending potential is the final voltage value at which the cyclic
	voltammetry will stop. It is a floating-point number representing the voltage in volts, in millivolts (mV)
	:param startingPotential: The starting potential is the initial voltage at which the cyclic
	voltammetry experiment begins, in millivolts (mV)
	:param scanRate: The scan rate is the rate at which the potential is swept during the cyclic
	voltammetry experiment. It is usually expressed in millivolts per second (mV/s)
	:param stepSize: The step size is the increment or decrement in potential applied during each step
	of the cyclic voltammetry experiment. It determines the resolution of the measurement and can be
	positive or negative, in millivolts (mV)
	:param numberOfCycles: The numberOfCycles parameter specifies the number of cycles to perform in the
	cyclic voltammetry experiment
	:param settlingTime: The settlingTime parameter refers to the time in seconds that the system should
	wait before starting the cyclic voltammetry measurement. This allows the system to stabilize and
	reach a steady state before the measurement begins, in milliseconds (ms)
	"""
	CVCommandString = "CVW," + str(endingPotential) + "," + str(startingPotential) + \
	"," + str(scanRate) + "," + str(stepSize) + "," + str(numberOfCycles)
	sendCommandToMCU(CVCommandString) # send the CV command


# ***** ***** ***** MAIN ***** ***** *****:

# MAX NO. OF POINTS TO STORE
queVoltage = deque(maxlen = 2000)
queCurrent = deque(maxlen = 2000)

ser = serial.Serial('COM6', 115200)

while True:
	messageReceived = getMessageFromOpenAFE()

	if messageReceived == -1:
		print("*** ERROR: Message corrupted!")
		break

	elif messageReceived == "MSG,RDY":
		makeCyclicVoltammetry(endingPotential_millivolts,startingPotential_millivolts, \
			scanRate_millivoltsPerSecond, stepSize_millivolts, numberOfCycles, settlingTime_milliseconds)

		messageReceived = getMessageFromOpenAFE() 
		if messageReceived[:-4] == "ERR":
			print("*** ERROR: MCU declined command")
			break
		
		while True:
			messageReceived = getMessageFromOpenAFE()
			point = messageReceived[4:] 
			# print(messageReceived[4:]) # De-comment to print the voltammetry points
			
			if messageReceived == "MSG,END":
				plotPoints(queVoltage, queCurrent)
				print("INFO: Voltammetry finished!") 
				plt.show()
				break
			
			if messageReceived[:-4] == "ERR":
				print("*** ERROR: An error ocurred")
				break

			elif messageReceived != -1: # if message is valid
				pointObjs = point.split(',')

				voltage = float(pointObjs[0])
				current = float(pointObjs[1])

				queVoltage.append(voltage)
				queCurrent.append(current)

				if len(queVoltage) % 20 == 0: 
					plotPoints(queVoltage, queCurrent)
			
		break